<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML">
    </script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">

    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <!-- Popper JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>

    <!-- Latest compiled JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
    
    
</head>
    
<body>
    <div>
        <img id="content-img" src="./images/content.jpg" height="256">
        <img id="style-img" src="./images/bricks.jpg" height="256">
        <img id="gen-img" src="./images/statue_of_liberty.jpg" height="256">
    </div>
    <input name="imgFile" type="file" id="fileSelect" accept="image/*" style="display:none">

    <script>
        console.log('Loading Model...');
        async function loadModel() {
            vgg16_model = await tf.loadLayersModel('./model/model.json')
            //warm up 
            /*
            const temp = get_wb('block1_conv1')
            temp[1].print()
            */
            console.log('Loaded!')
        }
        

        //取vgg16模型layer_name层参数(w,b)
        function get_wb(layer_name)
        {
            const kernel = vgg16_model.getLayer(layer_name)['kernel'].val
            const bias = vgg16_model.getLayer(layer_name)['bias'].val
            return [kernel,bias]
        }

        function conv_relu(input,wb)
        {
            return tf.tidy(()=>{
                const conv = tf.conv2d(input,wb[0],strides=[1,1],pad='same')
                const relu = tf.relu(tf.add(conv,wb[1]))
                return relu
                }
            )
        }

        function pool(input)
        {
            return tf.maxPool(input,filterSize=[2,2],strides=[2,2],pad='same')
        }
        
        function get_random_img()
        {
            return tf.tidy(()=>{
                const noise_image = tf.randomUniform([1,IMAGE_HEIGHT,IMAGE_WEIGHT,3],-20,20,dtype='float32')
                const random_image = tf.mul(noise_image , NOISE).add(tf.mul(content_img , tf.sub(tf.scalar(1) , NOISE)))
                return random_image}
            )
        }
        
        
        // Helper function for setting an image
        function setImage(element, selectedValue) {
            if (selectedValue === 'file') {
            //console.log('file selected');
            fileSelect.onchange = (evt) => {
                const f = evt.target.files[0];
                const fileReader = new FileReader();
                fileReader.onload = ((e) => {
                element.src = e.target.result;
                });
                fileReader.readAsDataURL(f);
            }
            fileSelect.click();
            } else if (selectedValue === 'pic') {
                openModal(element);
            } else if (selectedValue === 'random') {
                const randomNumber = Math.floor(Math.random()*links.length);
                element.src = links[randomNumber];
            } else {
                element.src = 'images/' + selectedValue + '.jpg';
            }
        }

        function buildModel()
        {
            net_input = tf.variable(tf.zeros([1,IMAGE_HEIGHT,IMAGE_WEIGHT,3],dtype='float32'))
            net_conv1_1 = conv_relu(net_input,get_wb('block1_conv1'))
            net_conv1_1.print()
            net_conv1_2 = conv_relu(net_conv1_1,get_wb('block1_conv2'))
            net_pool1 = pool(net_conv1_2)
            net_conv2_1 = conv_relu(net_pool1,get_wb('block2_conv1'))
            net_conv2_2 = conv_relu(net_conv2_1,get_wb('block2_conv2'))
            net_pool2 = pool(net_conv2_2)
            net_conv3_1 = conv_relu(net_pool2,get_wb('block3_conv1'))
            net_conv3_2 = conv_relu(net_conv3_1,get_wb('block3_conv2'))
            net_conv3_3 = conv_relu(net_conv3_2,get_wb('block3_conv3'))
            net_pool3 = pool(net_conv3_3)
            net_conv4_1 = conv_relu(net_pool3,get_wb('block4_conv1'))
            net_conv4_2 = conv_relu(net_conv4_1,get_wb('block4_conv2'))
            net_conv4_3 = conv_relu(net_conv4_2,get_wb('block4_conv3'))
            net_pool4 = pool(net_conv4_3)
            net_conv5_1 = conv_relu(net_pool4,get_wb('block5_conv1'))
            net_conv5_2 = conv_relu(net_conv5_1,get_wb('block5_conv2'))
            net_conv5_3 = conv_relu(net_conv5_2,get_wb('block5_conv3'))
            net_pool5 = pool(net_conv5_3)
        }

        function loss()
        {
            
        }

        function gram(x,size,deep)
        {
            return tf.tidy(()=>{
            const y = x.reshape([size,deep])
            const z = tf.matMul(tf.transpose(y),y)
            return z}
            )
        }

        function preprocess(image)
        {
            return tf.tidy(
                ()=>
                {
                    const tensor = tf.browser.fromPixels(image).toFloat()
                    const resized = tf.image.resizeBilinear(tensor, [IMAGE_HEIGHT, IMAGE_WEIGHT])
                    const reshape = resized.expandDims(0)
                    const changed = reshape.sub(IMAGE_MEAN_VALUE)
                    return changed
                }
            )
        }
        function train()
        {
            
        }

        function main()
        {
            
        }
        
        var vgg16_model;
        var content_img; 
        var contentImage = document.getElementById("content-img");
        var style_img; 
        var styleImage = document.getElementById("style-img");
        var fileSelect = document.getElementById("fileSelect");
        const IMAGE_HEIGHT = 224;
        const IMAGE_WEIGHT = 224;
        const NOISE = tf.scalar(0.5);
        const IMAGE_MEAN_VALUE = tf.scalar(128.)
        var net_input;
        var net_conv1_1;
        var net_conv1_2;
        var net_pool1;
        var net_conv2_1;
        var net_conv2_2;
        var net_pool2;
        var net_conv3_1;
        var net_conv3_2;
        var net_conv3_3;
        var net_pool3;
        var net_conv4_1;
        var net_conv4_2;
        var net_conv4_3;
        var net_pool4;
        var net_conv5_1;
        var net_conv5_2;
        var net_conv5_3;
        var net_pool5;

        //测试单元
        async function test()
        {
            await loadModel();
            //vgg16_model.summary()
            //console.log(tf.memory())
            //const input = tf.ones([1,224,224,3])
            //const wb = get_wb('block1_conv1')
            //const ret = conv_relu(input,wb)
            //const ret1 = pool(ret)
            //ret.print()
            //ret1.print()
            //content_img = tf.ones([1,IMAGE_HEIGHT,IMAGE_WEIGHT,3])
            //const temp = get_random_img()

            //setImage(contentImage,'bricks')
            //test_img.print()
            //gram(tf.tensor2d([1,2,3,4,5,6],[2,3]),2,3).print()
            //buildModel()
            //buildModel()
            //net_pool5.print()
            //preprocess(contentImage).print()
            console.log(tf.memory())
        }
        test();
        
    </script>
</body>

</html>